def top_right_half(img):
    img2=img.clone()
    batch_size, channels, height, width = img2.shape
    for b in range(batch_size):
        for c in range(channels):
            for h in range(height):
                for w in range(width):
                    if h>=height/2 or w>=width/2:
                        img2[b][c][h][w]=0; # Set all pixel values not in top right half of image to 0,effectively cropping the image. Can change the are of interest.
    return img2

def cal_mae(img_root,gt_dmap_root):
    '''
    Calculate the MAE of the test data.
    img_root: the root of test image data.
    gt_dmap_root: the root of test ground truth density-map data.
    model_param_path: the path of specific mcnn parameters.
    '''
    dataset=CrowdDataset(img_root,gt_dmap_root,8,phase='test')
    dataloader=torch.utils.data.DataLoader(dataset,batch_size=1,shuffle=False)
    model.eval()
    mae=0
    my_list=[]
    with torch.no_grad():
        for i,(img,gt_dmap) in enumerate(tqdm(dataloader)):
            if i<300:                #Set i for number of images to check results on 
                img2=top_right_half(img)
                img2=img2.to(device) #img2 is cropped version of img. We will compare ground density maps generated by model on img v/s img2.
                img=img.to(device)
                gt_dmap=gt_dmap.to(device)
                et_dmap=model(img)
                et_dmap2=model(img2)
                et_dmap=top_right_half(et_dmap)
                et_dmap2=top_right_half(et_dmap2)   #Crop the estimated and tru ground density maps only to the relevant area
                my_list.append(et_dmap.data.sum()-et_dmap2.data.sum())
                del img,gt_dmap,et_dmap
    print("Average: ",sum(my_list)/len(my_list))
